[scope] Define Project Scope (complete)
Multiplayer contract bridge playable in a web browser.
Four human players sit at a virtual table, bid, and play tricks in real time.
> Target modern evergreen browsers only — no IE, no polyfills.
> MVP is a single rubber; tournament/duplicate scoring is a stretch goal.

[rules-research] Research Bridge Rules (complete)
Compile the authoritative rules for contract bridge.
Covers the auction, declarer/dummy play, trick resolution, and rubber scoring.
> Use the 2017 Laws of Duplicate Bridge as a baseline, simplified for social play.
> Ignore alerting and convention cards in v1.
-> scope

[multiplayer-arch] Choose Multiplayer Architecture (complete)
Evaluate peer-to-peer vs. authoritative server for four-player card games.
Hidden information (each player's hand) rules out pure P2P without encryption tricks.
> Authoritative server — clients send intents, server validates and broadcasts state.
> WebSocket for real-time; fall back to long-poll only if needed.
> One server process per table; horizontal scale via container orchestration.
-> scope

[ui-vision] Sketch UI Vision (started)
Explore how the table, cards, and bidding box should look and feel.
First-person perspective: your hand at the bottom, partner across, opponents left and right.
> First-person POV, not top-down bird's eye — more immersive.
> Animate card play with spring physics for a satisfying feel.
> Dark felt-green table background; clean sans-serif for bid labels.
-> scope

[bid-design] Design Bidding System (started)
Map out the auction state machine: who bids, legal calls, when the auction closes.
A call is one of: a suit bid (level + strain), Pass, Double, or Redouble.
The auction ends after three consecutive passes following at least one bid.
> Model as a finite state machine with four seats rotating.
> Validate legal calls on the server; client shows only legal options.
-> rules-research

[scoring-design] Design Scoring Engine (complete)
Define how tricks convert to points under rubber bridge scoring.
Below-the-line points for contracted tricks, above-the-line for overtricks, honors, and bonuses.
A side wins the rubber by winning two games; a game is 100+ below-the-line points.
> Implement rubber scoring first — it's simpler and more social.
> Store a detailed score sheet as structured data, not just a total.
-> rules-research

[card-engine] Build Card Engine (started)
Model a 52-card deck, shuffle with Fisher-Yates, and deal four 13-card hands.
Expose helpers: sort by suit/rank, check if a card is legal to play given the led suit.
> Use a seeded PRNG on the server so deals are reproducible for replay.
-> bid-design
-> scoring-design

[bid-engine] Build Bidding Engine (notstarted)
Implement the auction state machine that accepts calls and tracks the contract.
Validate each call against the Laws: a new bid must be higher than the last; doubles and redoubles have specific preconditions.
Output the final contract (level, strain, declarer, doubled/redoubled) or "all pass."
-> card-engine

[trick-engine] Build Trick Engine (notstarted)
Manage the play phase: thirteen tricks, four cards each.
Enforce follow-suit rules. Determine trick winner by rank and trump.
Handle the dummy's exposed hand — declarer selects dummy's cards.
-> bid-engine

[scoring-impl] Implement Scoring Engine (notstarted)
Translate completed deals into rubber bridge scores.
Calculate below/above the line, vulnerability, slam bonuses, honors.
Track cumulative rubber state across multiple deals.
-> trick-engine
-> scoring-design

[table-ui] Build Table UI (notstarted)
Svelte components for the card table: four hand areas, a played-card area, and a trick pile.
Cards fan out in your hand — click or drag to play.
Animate cards from hand to table with a spring transition.
-> card-engine
-> ui-vision

[bidding-ui] Build Bidding UI (notstarted)
A bidding box component that shows all legal calls for the current auction state.
Display the auction history as a four-column table (N, E, S, W).
Highlight the final contract after the auction closes.
-> bid-engine
-> ui-vision

[lobby] Build Lobby & Matchmaking (notstarted)
A landing page where players create or join a table.
Four seats fill up; game starts automatically when all seats are occupied.
Show a shareable link so friends can join directly.
-> multiplayer-arch

[realtime] Build Real-Time Server (notstarted)
Node.js WebSocket server that hosts one game per table.
Receives player intents (play card, make bid), validates via engines, broadcasts new state.
Serialize game state so disconnected players can rejoin mid-hand.
-> multiplayer-arch
-> trick-engine
-> bid-engine

[integrate] Integrate Client and Server (notstarted)
Wire the Svelte UI to the WebSocket server.
Client sends intents; server responds with authoritative state diffs.
Handle reconnection, latency hiding, and optimistic UI updates.
-> table-ui
-> bidding-ui
-> realtime
-> lobby

[ai] Add Robot Player (planning)
A rule-based bot that can fill an empty seat so three (or fewer) humans can still play.
Start with a simple heuristic: bid up with 13+ HCP, lead top of a sequence, second hand low, third hand high.
> Rule-based first, not ML — keep it deterministic and debuggable.
> Bot should announce itself in the lobby so players know it's not human.
-> integrate

[playtest] Playtest Full Rubbers (notstarted)
Run complete four-player rubber sessions end-to-end.
Verify scoring, trick resolution, and auction edge cases against manual calculations.
Capture at least ten replays as regression fixtures.
-> integrate
-> scoring-impl

[polish] UI Polish & Accessibility (notstarted)
Add keyboard navigation for card selection and bidding.
Screen-reader labels for every card and bid.
Responsive layout for tablets; not targeting phones in v1.
-> playtest

[ship] Ship v1 (notstarted)
Deploy server to a container host, static assets to a CDN.
Write a one-page "How to Play" guide embedded in the lobby.
Announce to friends and gather feedback for v2.
-> playtest
-> polish
-> ai

[root] Browser Bridge (started)
A multiplayer contract bridge game in the browser.
Four players, real-time bidding and play, rubber scoring — all from a URL.
-> scope
-> rules-research
-> multiplayer-arch
-> ui-vision
-> bid-design
-> scoring-design
-> card-engine
-> bid-engine
-> trick-engine
-> scoring-impl
-> table-ui
-> bidding-ui
-> lobby
-> realtime
-> integrate
-> ai
-> playtest
-> polish
-> ship
